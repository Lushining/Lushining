一、java概述
1.特性
1.1解释性语言(java)：编译后的代码不能直接被机器执行，需要解释器(JVM)执行；
   编译性语言(c/c++)：编译后的代码(二进制)可以直接被机器执行
1.2跨平台性：同一个java程序(.class)可以通过JVM在多个系统(windows/Linux)运行
   
2.程序安装与运行机制
2.1相关程序：目录名不含中文与空格
   JDK(java开发工具包)=JRE+开发工具(java,javac,javadoc,javap)
   JRE(java运行环境)=JVM+java核心类库  #若要运行已开发的java程序，只需安装JRE
   JVM(java虚拟机)：屏蔽底层运行平台差异，实现“一次编译，到处运行”
   path：提供cdm中java指令的可执行程序的路径
   classpath：通知JVM用户类的存放路径。
2.2配置环境变量：cmd执行的程序要在当前目录下存在
   添加环境变量：此电脑-属性-高级系统设置-环境变量-增加JAVA HOME环境变量并指向jdk安装目录
   编辑环境变量，增加 %JAVA_HOME%bin （必须保存）
2.3运行机制
   源文件(.java)--编译(javac)--字节码文件(.class)--运行(java)--输出(JVM)
2.4注意事项：
   源文件由类组成，每一个类代表一个程序的入口，对应一个字节码文件
   一个源文件最多有一个public类,若存在则文件名必须为该类的类名
   严格区分大小写，每个语句必须由";"结束,{}成对出现

3.基本知识：
3.1转义字符(ChangeChar.java)
  \t  \n  \\  \\\\  \"  \'  \r
3.2注释：
   单行注释：//
   多行注释：/*  */
   文档注释(Comment.java)：
   ①作用：注释内容可以被javadoc解析，生成以网页文件体现的文档
   ②格式：/**
           * author Lushining   #javadoc标签(固定list)
           * version 1.0
         */
   ③实现：javadoc -d <文件夹名> -xx -yy(tags) <.java>

3.3代码规范
   类和方法的注释用文档注释
   运算符前后默认加空格
   源文件使用UTF-8编码(GBK保存是为了执行效果)

3.4了解dos命令
  ①相对路径：在当前目录下定位路径
     绝对路径：从顶级目录开始定位路径
  ②基本指令
   help <dos>  ：查看指令的使用方法
   dir <file>  :查看当前/指定目录内容      
   cd</D> <C> ：切换到其他盘      
   cd <file>：切换到当前盘其他目录  #绝对路径/相对路径
   cd <../\>：返回上一级目录/直接跳转到根目录
   tree     ：查看指定目录下所有子目录(树状图)
   cls      ：清屏
   exit     ：退出dos
   md/rd    ：创建/删除目录        #md <> <>可同时操作多个
   copy     ：拷贝文件             #copy ok.txt <绝对路径>，可在绝对路径进行改名
   del      ：删除文件             #del hello.txt
   echo     ：创建文件并输入内容    #echo hi > hello.txt
   type     ：创建空文件           #type nul > blanket.txt
   move     ：剪切文件             #move ok.txt <绝对路径>

二、变量
1.变量：类型+名称+取值  #int a = 1
1.3注意事项×5
   一个变量表示内存中的一个储存区域
   不同的变量可以有不同的类型和占用空间(字节)
   变量必须先定义(声明+赋值)再使用
   同一作用域的变量值可以在同一类型范围内变化(更新变量值)
   变量在同一个作用域不能重名  #作用域=类/方法
2.“+”:从左到右运算,数值间加,字符串则拼接  //“hi”+1+2=hi12;1+2+"hi"=3hi

3.数据类型
3.1基本数据类型
  整数类型：byte[1],short[2],int[4],long[8]  
    ①默认int，long后加”L“，double后加”D“
    ②常量赋值先判断范围;变量赋值考虑精度  #byte/short a = 1 √
  浮点类型：float[4],double[8]
    ①浮点数=符号位+指数位+尾数位
    ②默认double，float后加'F'
    ③十进制计数：0.512=.512；512.0
     科学计数法：5.12e2=5.12*10^2；5.12E-2=5.12/10^2
    ④计算得近似值：double a=8.1/3  //2.6999...97
     ->计算结果的相等判断：if(a=b)/(Math.abs(a-b)<0.0001);
  字符型：char[2]:本质是可运算的整数，输出unicode码对应的字符
  布尔型：boolean[1](true/false)
3.2引用数据类型
   类class：字符串"String"
   接口interface
   数组[]

4.编码
  ASCII[1]       ：一共有128个字符(第一位统一为0)，不能表示中文
  Unicode[2]     ：拓展ASCII(0-127的字符相同)，可表示所有语言
  utf-8[1,6]     ：改进unicode(可变大小)   #表示的中文[3]更多，转GBK可能报错
  gb2312<gbk[1/2]：可表示汉字              #big5繁体中文

5.基本数据类型转换
5.1自动类型转换规则
   ①精度小自动转为精度大，超过精度则报错(特例：数值型的常量赋值)
    转换：char-int-long-float-double/byte-short-int-long-float-double
    示例：int a='c'//97 ; double b=80//80.0 ；byte a=1000
   ②(byte/short)与char之间不能自动转换，boolean不参与转换
   ③byte,short,char之间的运算：转为int计算
   ④混合运算：转换成精度最大的再计算并输出
5.2强制类型转换规则
   ①加强制符()容量大->容量小，可能造成精度损失或数据溢出
   ②只针对最近的操作数有效，可用小括号提升优先级
   ③char自动保存int常量值，保存int变量值需要强制转换
    char a1=100//√ ; char a2=a1//× ; char a3=(char)a1//√ ；
5.3基本数据类型与String：必须保证格式正确(String"hi"->int异常)
   ①->:基本类型的值+""
   ②<-:调用包装类的parseXX方法
    int num1 = Integer.parseInt(a);
   ③String->char:String.chartAt(0)
    String a="123" ; char b=a.charAt(0)  #取出第一个字符

三、运算符：
*优先级：括号-单目-算数-位移-关系(后==/!=)-逻辑(&-^-|-短路)-三元-赋值
 运算顺序：单目(++/--/！/~)/赋值从右向左
1.算数运算符：混合运算取大精度
  /除号(截位)   ：2/5=0;2/5.0=0.4；
  %取余(a-a/b*b)：-10%3=(-10)-(-3*3);10/-3=10-(-3)*(-3);-10/-3=-1
   a为double：强转{#a-(int)a/b*b}+输出近似值(可能有多位小数)    #-10.5%3=-1.5
  ++自增：作为独立语句：int i=10,i++=++i=i+1;
         表达式(前/后)：int a=8,b=++a/a++//a=9,b=9/8;
                     * int i=1,i=i++//1  #temp=i=1,i=i+1,i=temp
                       int i=1,i=++i//2  #i=i+1,temp=i=2,i=temp
2.位移运算符
2.1进制：不区分大小写
2.1.1整数进制：二(以01/0B开头) 十 八(以0开头) 十六(0-9 A-F，以0x/0X开头)
2.1.2进制转换：
  转十：最低位开始取数乘以X的(位数-1)次方
  十转：不断除以X再倒取余
  二转：三位/四位一组转一位 
  转二：一位转三位/四位
2.2二进制的原码、反码、补码
  最高位是符号位，0正1负
  正数和0三码合一
  负数反码=原码符号位不变，其他位取反;补码=反码+1
  计算机使用补码运算，原码展示运算结果
2.3位运算(二进制)：得补码-按位运算-转原码-十进制输出
2.3.1按位逻辑运算：
  &按位与：均1得1
  |按位或：有1得1
  ^按位异或：不同得1
  ~按位取反
2.3.2按位位移
  <<算数左移   ：符号位不变，低位补零；            #1<<2:00000010->00001000=1*2*2=4
  >>算数右移   ：符号位不变，低位溢出，高位补符号位；#1>>2:00000010->00000000=1/2/2=0
  >>>无符号右移：符号位变，低位溢出，高位补零       #3>>>2:00000011->00000000=
3.关系运算符：输出boolean(true/false)
  ==相等(=赋值/字符串equals)    !=不等于
  instanceof：是否是类的对象
4.逻辑运算符：连接多个条件，输出boolean(true->执行)
  短路与&&：条件一false则直接输出，不执行后续语句
  逻辑与& ：执行所有语句
  |/||或
  ！取反：!a(T->F,F->T)
  ^ 异或：a^b(==->F,!=->T)
5.三元运算符可嵌套：
  条件表达式？表达式1：表达式2  #T->1,F->2
  *表达式1/2要为可以接受赋值变量的类型(自动/强制)
   int a=1;int b=2;int c = a>b?(int)1.1:(int)2.2;
                   double d = a>b?1.1:2.2/a:b+3;
6.赋值运算符：左边为变量，右边可以是变量、常量、表达式
  基本/复合：a+=b == a=a+b；
  复合赋值运算符进行强制类型转换：
    byte b=3;b+=2  == b=(byte)(b+2) ；b++ == b=(byte)(b+1)
    byte b=3;b=b+2 #int->byte 报错

7.标识符命名规则和规范
  组成：字母数字 _ $，数字不开头，不含空格.严格区分大小写
  不直接使用关键字或保留字（可包含）
  包名均小写：com.hsp.crm
  类和接口名首大写：TankShotGame
  变量与方法名第二首开始大写：tankShotGame
  常量名_连接均大写：TAX_RATE

四、程序控制结构
1.分支控制:
1.1单分支：if(条件){}  //true执行,false跳过
1.2双分支：
   if(){代码块1;}
   else{代码块2;}    //true1，false2
1.3多分支:最多有一个程序入口
   if(条件1){代码块1;}
   else if(条件2){代码块2;}
   ......
   else{代码块n}    //自定义：若上述条件均不成立则else，否则无执行
1.4switch分支
  switch(表达式){   //表达式与case数据类型一致或可自动转化
                   //限定数据类型：byte,short,int,char,enum枚举,String
      case 常量1：  //<常量/常量表达式('a'+1)>，不能是变量
          语句块1； //case不同常量值相同输出可合并
          break；  //有则退出switch，无则直接执行2
  ......
      default:     //可自定义，均不匹配则执行
          语句块；
  }

2.循环控制
2.1for循环
   for(变量初始化;循环条件;变量迭代){}
*使用细节：
①循环条件返回boolean值；（true）无限循环
②形式2：初始化 /t for(;循环条件;) /t 循环操作 /t 迭代
  (;)无限循环
③初始值和迭代可以是多条语句,要求类型一样并且用逗号隔开
2.2while循环：先判断再执行
   变量初始化；
   while(循环条件){  
      循环语句块；
      变量迭代；
   }  
2.3do..while循环：先执行再判断(至少执行一次)
   循环变量初始化；
   do{
      循环语句块；
      循环变量迭代；
   }while(循环条件)；
2.4多重循环：定义变量-内循环-外循环-优化
   *打印金字塔(矩形-半个-整个-空心)

3.跳转控制语句：
3.1break跳出控制：终止switch/循环
  if(){......  //t->执行break，跳出循环
       break;  //f->不执行break，继续循环
       ......
      }  //默认退出最近的循环；定义标签-<label:>指定退出的具体循环
3.2continue：结束本次循环，继续执行下一次循环
3.3return：跳出所在的方法(写在main方法下则跳出所在的程序）

五、数组
1.一维数组：
1.1格式：
   声明再创建：<int>[] <a>;
              a = new <int>[length];
   创建再写入：<int> <a>[] = new <int>[length];
              <a>[i] = <num>;
   创建并写入：<int>[] <a> = {....};
1.2遍历元素：<变量名>[i]  #i∈[0,i-1]
   *优化：for( ;< arr.length; )
1.3数组反转：反转规律(temp+arr[]=arr[])/逆序遍历(arr1=arr2)
1.4数组增减：创建新数组[arr.len±1]-循环赋值
1.5冒泡排序：1.外循环(i<arr.length-1)：表示内循环的次数
           2.内循环(j<len-1-i)：依次比较相邻元素，若逆序则交换；
1.6数组查找：使用标识符判断查找是否成功(int index = ±1)
1.7使用细节：
   ①存放任何类型，但不能混用或可自动类型转换(int->double)
   ②不赋值则默认：0/0.0,char(\u0000)boolean(false),String(null)
2.二维数组：
2.1格式：<int>[][] arr= {{},{},...}
   *列数不定:int[][] arr = new int[3][],循环创建一维空间并赋值
2.2遍历：arr[i]     获取第i+1个元素(第i个数组)
        arr[i][j]  获取第i+1个元素的第j+1个元素
3.JVM内存形式：
  一维：栈(变量->值;数组->地址)--堆(值/地址)-方法区(常量池)
        基本数据类型传递具体值,互不影响；引用数据类型(数组)传递地址，相互影响；
  二维：栈(二维->地址)->堆(一维->地址->具体值)
六、面向对象编程(基础)
1.类与对象：
1.1定义
   类->自定义数据类型
   对象->一个具体实例，包括属性和行为
1.2成员变量(属性)：可为任意数据类型，默认值同数组
   创建属性：Class <n>{() <type> <t_n>}  //访问修饰符：public,protected,默认,private
   访问属性：<c_n>.<t_n>                //同类直接访问，跨类先创建对象
1.3成员方法(行为)
   创建类与方法：
   public void <>(){}    //void无返回值；形参任意个数和类型,实参个数顺序一致，类型兼容
   public <type> <>(){   //<type>：限制输出数据类型，进行自动类型转换；
       return <值/变量>;} //一个方法最多一个返回值(定义数组返回多个值)；
   调用方法：<o_n>.<m_n>();//同类下的方法直接调用用，跨类需创建对象
1.4JVM运行机制
   ①创建对象：方法区加载类信息->堆开辟对象空间(地址)
             ->属性初始化(默认->指定->构造器)->栈对象名赋予地址
     *地址置空(<o_n> = null)与异常：引用/具体
   ②成员方法(Ct06)：关注各自栈空间，程序结束则销毁

2.递归(成员方法的循环使用)
2.1JVM内存形式：
   ①递归产生独立方法栈，递归结束则销毁
   ②递归执行完整代码：方法执行完毕或遇return则返回；
2.2经典案例(定义参数+策略)：
   ①走迷宫：0-路，1-障碍，2-通路，3-死路；循环方法：下右上左判断
   ②汉诺塔：a-起，c-终，b-中；a小(n-1)->b，a大->c，b所有(n-1&b->起)->c；
   *回溯现象：当前plana/b/c/d均不成功则返回上一步的planb
   ③八皇后

3.方法重载：同类中，允许创建多个同名但形参列表不同(类型/个数/顺序)的方法
  可变参数：同类中，允许将多个同名同功能但参数个数不同的方法封装
          ①<type>... n：n==数组，可接收任意个数参数，遍历访问
          ②一个形参列表最多有一个可变参数，且必须放在末尾
  全局变量(属性)与局部变量(成员方法变量)：
  ①作用域：本类直接用，其他类通过创建对象/传参调用；本方法内；
  ②默认值：有默认值可直接使用；必须赋值使用；
  ③生与消：随对象存在或消失；随代码存在或消失；
  ④修饰符：允许添加；禁止
  ⑤变量名：属性与局部变量重名则就近访问；同一个作用域内局部变量不能重名；
4.构造器
  创建：<public> <类名>(){  //默认无参,自定义后覆盖更新(重建无参)；
           属性=形参；}    //允许重载；
  调用：<c_n> <> = new <c_n>(); //创建对象时自动调用；
5.this(当前对象)：
  ①只能在类定义的方法中使用(成员方法/构造方法)
  ②区分属性与局部变量：this.变量名 == 属性;无参方法直接访问属性；
  ③调用成员方法：this.方法名(实参);  //调用本类的方法
  ④调用构造器：this(实参);  //仅在构造器中使用且必须是第一条语句
  ⑤JVM内存形式：堆：对象空间：this空间(this地址=对象地址,指向对象自身)

七、面向对象编程(中级)
1.IDEA入门：scr(.java)；out(.class)
1.1快捷键：剪切X  撤销Z 复制C 粘贴V 删除词尾Back 删除行Shift+Del
          查看类的层级关系Ctrl+H 查看方法Ctrl+B
          导入所需类Alt+Enter   快速运行Alt+R
          格式化Ctrl+Alt+L     构造Alt+Fn+ins
          自动分配变量名：new Person().var + Enter
1.2模板：main sout fori  //设置-实时模板-自定义(作用域Java)

2.包：创建不同文件夹管理类文件，控制访问范围(访问修饰符)
2.1创建：package <包名>;
   同包下的类直接调用;异包先导入/通过包名调用类
   import <包名>.<类名>；  //import c01.Dog;new Dog();
   new <包名>.<类名>();   //new c02.dog()
2.2命名:数字\字母\下划线\小圆点;字母不开头,无关键字保留字
   规范:com.公司名.项目名.业务模块名
2.3常用包:
   java.lang  //默认使用无需导入:Math.abs();Math.PI
   java.util.*(Scanner/Random/Arrays);  //*导入所有类
     ①键盘输入：
     创建对象：Scanner myScanner = new Scanner(System.in);
     调用功能：String name = myScanner.next();//String
             int age = myScanner.nextInt();//int/double...
             char gender = myScanner.next().charAt(0);
     ②产生随机数：
     创建对象：Random r = new Random();
     调用功能：Int num = r.nextInt(3)  //[0,bound)
     ③排序:Arrays.sort
     ④日期:new Date-new SDF("yyyy-MM-dd HH:mm")-sdf.format(date)
   java.net网络开发;java.awt界面开发

3.访问修饰符:允许修饰类(仅public&默认)/属性/方法
  public:允许不同包访问
  protected:允许子类与本包访问
  默认:允许本包访问
  private:允许本类访问

4.特征
4.1封装:通过公共方法调用私有属性与方法
   ①将属性/方法私有化:private <type> 属性;  //不能跨类访问属性
   ②提供公共set方法:过滤实参并赋值
     public void setXxx(){过滤输入;属性=参数名;}  //Xxx-某属性
   ③提供公共get方法:获取属性值
     public <type> getXxx(){权限判断;return;}
   *构造器赋值:无视封装的过滤条件
   *构造器配合封装:使用setXxx()赋值,受过滤条件制约
4.2继承:class 子类 extends 父类{}
4.2.1JVM内存机制:
   创建对象:方法区加载类信息(显示继承关系)->堆创建对象空间->
            根据继承关系顺序开辟独立变量空间并赋值->地址返回栈的对象名
   顺序访问:本类是否存在->存在并允许访问则返回/无则向顶级查找->无权限/找不到报错
4.2.2使用细节:
   ①子类继承父类的所有代码,但必须通过父类提供的公共方法才能访问私有;
   ②创建子类对象时,默认super()先调用父类的无参构造器完成初始化
                或通过super(形参)指定父类的构造器创建对象;
   ③单继承迭代机制
   ④super:定位父类,就近访问且受权限制约
     this :定位子类,顺序访问且授权限制约
     两者必须在构造器的第一行使用,不共存
4.2.3重写:顺序访问时子类方法重写父类
  ①名称与参数一致,返回类型一致或有继承关系,禁止缩小父类的访问权限
  ②重写vs重载:范围(本类/继承),形参(不同/一致).返回(无要求/一致或继承),修饰符(无要求/不缩小)

4.3多态:
4.3.1表现形式：
  ①建立在封装和继承之上
  ②方法通过重写或重载体现多态；对象通过更改运行类型体现多态;
4.3.2运行机制
  ①原理:固定的编译类型(父类)=可变的运行类型(子类)
        编译类型决定属性值;方法编译定位父类,运行定位子类再顺序访问;
        对象名 instanceOf 类(t/f):运行类型是否属于XX类/XX类的子类
  ②向上转型:
    本质:父类的引用指向子类对象      //Animals a=new Dog();a=new Cat();
    特点:编译时,可以按权限调用父类所有成员,不能调用子类特有成员;
        运行效果从子类开始体现;
  ③向下转型:
    本质:强制转换父类引用的编译类型   //Dog dog = (Dog) animal
    特点:强转类型与父类引用类型一致;  //animal/dog->Dog对象
        可以调用子类中的所有成员
  ④动态绑定机制:调用方法绑定运行类型,方法中的属性绑定当前类
4.3.3多态的应用
多态数组:
  ①定义一个父类类型的数组,保存不同的子类或父类对象
  ②实现:遍历访问不同的对象重写方法;
        子类特有则(instanceOf判断运行类型+向下转型)
多态参数:
  ①创建:形参列表定义为父类,实参传入不同的子类或父类
  ②实现:测试类编写方法,(创建本类对象)通过实参重写方法;
        子类特有则(instanceOf过滤+向下转型)

5.Object类(顶级父类)
5.1 equals:两个对象类型是否相等
  ①运算符(==):判断任意类型(基本类型的值/引用类型的地址)
  ②方法(equals):(object)判断引用类型(String)
  ③重写判断内容:多态参数obj(向上转型)-同对象?-同类?-向下转型-相等判断(return)
5.2 hashCode:返回对象的哈希码值,类似但不等价于对象地址
5.3 toString:返回该对象的字符串表示
  ①默认返回:全类名(包+类)+@+十六进制哈希值
  ②重写返回属性:拼接字符串
5.4finalize:回收对象前调用该方法
  ①默认无处理,支持重写业务逻辑代码;
  ②无引用(地址置空)!=回收:System.gc()触发回收
5.5getClass().getName():返回运行包名.类名

6.断点调试(绑定运行类型):
   Debugger调试控制台 consume输出控制台
   F8逐行执行 ; resume(F9)执行下一个断点  //可动态设置
   F7步入自定义方法 ; 强制步入(aSF7)底层源代码  //可递归
   shift+F8步出:逐级退回方法调用处



补充资料：快捷键 文档注释标签目录 API文档 unicode编码表
tips：
1.String的相等比较：String.equals(string)
2.包装类：double vs Double(double/null)  //通过return null限定条件
3.API文档：说明类及其使用方法
  ①JDK8中文版：https://www.matools.com/api/java8、
  ②类的组织：JDK->包(..)-类(..)extends父类->属性/成员方法/构造器
  ③使用示例：寻找相应的包--类--方法；显示-索引-类(第一条)
4.查看JDK源码:ctrl+B
